/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef republic_TYPES_H
#define republic_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace edu { namespace rice { namespace republic { namespace amif {

struct ResponseType {
  enum type {
    ACCEPT = 0,
    DENY = 1
  };
};

extern const std::map<int, const char*> _ResponseType_VALUES_TO_NAMES;

typedef int64_t Bytes;

typedef std::string AppID;

typedef std::string DataID;

typedef std::string ServerID;

typedef std::string RequestID;

typedef std::string ResponseID;

typedef int64_t ResponseCode;

class Request;

class Response;

class Release;

typedef struct _Request__isset {
  _Request__isset() : rid(false), aid(false), did(false), datasize(false), remainingsize(false), sender(false), receivers(false) {}
  bool rid :1;
  bool aid :1;
  bool did :1;
  bool datasize :1;
  bool remainingsize :1;
  bool sender :1;
  bool receivers :1;
} _Request__isset;

class Request {
 public:

  Request(const Request&);
  Request& operator=(const Request&);
  Request() : rid(), aid(), did(), datasize(0), remainingsize(0), sender() {
  }

  virtual ~Request() throw();
  RequestID rid;
  AppID aid;
  DataID did;
  Bytes datasize;
  Bytes remainingsize;
  ServerID sender;
  std::set<ServerID>  receivers;

  _Request__isset __isset;

  void __set_rid(const RequestID& val);

  void __set_aid(const AppID& val);

  void __set_did(const DataID& val);

  void __set_datasize(const Bytes val);

  void __set_remainingsize(const Bytes val);

  void __set_sender(const ServerID& val);

  void __set_receivers(const std::set<ServerID> & val);

  bool operator == (const Request & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(aid == rhs.aid))
      return false;
    if (!(did == rhs.did))
      return false;
    if (!(datasize == rhs.datasize))
      return false;
    if (!(remainingsize == rhs.remainingsize))
      return false;
    if (!(sender == rhs.sender))
      return false;
    if (!(receivers == rhs.receivers))
      return false;
    return true;
  }
  bool operator != (const Request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Request &a, Request &b);

inline std::ostream& operator<<(std::ostream& out, const Request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Response__isset {
  _Response__isset() : rid(false), type(false), code(false), acceptedsize(false) {}
  bool rid :1;
  bool type :1;
  bool code :1;
  bool acceptedsize :1;
} _Response__isset;

class Response {
 public:

  Response(const Response&);
  Response& operator=(const Response&);
  Response() : rid(), type((ResponseType::type)0), code(0), acceptedsize(0) {
  }

  virtual ~Response() throw();
  ResponseID rid;
  ResponseType::type type;
  ResponseCode code;
  Bytes acceptedsize;

  _Response__isset __isset;

  void __set_rid(const ResponseID& val);

  void __set_type(const ResponseType::type val);

  void __set_code(const ResponseCode val);

  void __set_acceptedsize(const Bytes val);

  bool operator == (const Response & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(acceptedsize == rhs.acceptedsize))
      return false;
    return true;
  }
  bool operator != (const Response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Response &a, Response &b);

inline std::ostream& operator<<(std::ostream& out, const Response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Release__isset {
  _Release__isset() : rid(false) {}
  bool rid :1;
} _Release__isset;

class Release {
 public:

  Release(const Release&);
  Release& operator=(const Release&);
  Release() : rid() {
  }

  virtual ~Release() throw();
  ResponseID rid;

  _Release__isset __isset;

  void __set_rid(const ResponseID& val);

  bool operator == (const Release & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    return true;
  }
  bool operator != (const Release &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Release & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Release &a, Release &b);

inline std::ostream& operator<<(std::ostream& out, const Release& obj)
{
  obj.printTo(out);
  return out;
}

}}}} // namespace

#endif
